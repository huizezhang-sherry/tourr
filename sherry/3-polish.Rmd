---
title: "3-polish"
author: "Huize Zhang"
date: "25/02/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

load(here::here("sherry", "data", "geodesic_polished.rda"))
load(here::here("sherry", "data", "geodesic_alpha2.rda"))
load(here::here("sherry", "data", "data.rda"))
load(here::here("sherry", "data", "data_mult.rda"))
load(here::here("sherry", "data", "polish_holes.rda"))
load(here::here("sherry", "data", "polish_holes_mult.rda"))

load(here::here("sherry", "data", "polish_holes_old_mult_record.rda"))
load(here::here("sherry", "data", "polish_holes_old_mult_sim.rda"))

load(here::here("sherry", "data", "polish_mult_modified_record.rda"))


```

## Preliminary 

- I write a `search_polish()` function aiming to fining the global maximum after using `search_geodesic()`. This is implemented inside the `animate()` function. 

However, using it on the simulated data `geodesic_alpha` from `2-alpha_analysis` shows that the algorithm is not effective on picking the global maximum, see below:

```{r}
geodesic_clean <- geodesic_polished %>%
  filter(info %in% c("interpolation", "interpolation_polish")) %>%
  mutate(stepS = as.factor(stepS))

geodesic_interp <- geodesic_clean %>%
  group_by(stepS, polish_alpha) %>%
  mutate(id = row_number())

best <- geodesic_clean %>%
  group_by(stepS, polish_alpha, info) %>%
  mutate(id = row_number()) %>%
  filter(index_val == max(index_val))

geodesic_interp %>%
  ggplot(aes(x = id, y = index_val, col = info, group = stepS)) +
  geom_path() +
  ggrepel::geom_text_repel(data = best, aes(label = round(index_val, 4))) +
  facet_grid(stepS ~ polish_alpha)

```

Adding the polish step doesn't find a better basis for all the step_polish value and all the alpha value. This makes me want to understand more on how the ending interpolation bases locate for different alpha value. 


## Version 2

A polishing procedure is implemented for the final projection in 1D projection. The polishing step is described as follows: 

1. Set `grid_gap = 0.002` and `grid_vec <- c(-2, -1, 0, 1, 2) * grid_gap`
2. Apply this to all the element of the basis to form a grid.
3. Calculate the index value for each combination and output the basis with the largest index_val
4. repeat 1-3 for 10 times

This grid-based searching approach is not suitable for high dimensional data because grid searching sets the grid in a cubic while the sampling space in our case is a sphere.

A better approach is to prescribe an angle that determines a radius of the searching sphere. This angle-based polishing is implemented in version 3


## Version 3

### Procedure

Given the last basis (current) from tour and interpolation, `search_polish()` looks for bases nearby with higher index value. 

1. `polish_alpha` defines the angle to move from the current basis to a randomly generated basis in percentage.  `iter` defines the number of randomly generated sample to take. 
2. Form a grid value of `alpha_seq <- seq(0, polish_alpha, by = polish_alpha/10)` and generate `iter` number of bases for each `alpha` in `alpha_seq` (thus both inside and on the boundary)
3. Once the nearby bases are generated, compute the corresponding `index_val` and compare with `cur_index`. 
4. The basis with the largest `index_val` become the "current" basis in the next round. 
5. Repeat 2-4 for `nloop` number of times. 


### Examples

#### 1D projection with `x1, x2, x8: x10` using `holes()` index

```{r eval = FALSE}
set.seed(123456)
polish_holes <- animate_dist(data, tour_path = guided_tour(holes(), d = 1,
                                                search_f = search_geodesic_latest),
                  rescale = FALSE, polish = TRUE, nloop = 20, polish_alpha = 0.005)
```

```{r}
options(pillar.sigfig = 7)
polish_holes %>% filter(info == "polish") 
  
basis <- polish_holes %>% filter(info == "polish") %>% pull(basis) 
basis_0 <- matrix(c(0, 1, 0, 0, 0))
basis_1 <- basis %>% first()
basis_2 <- basis %>% last()
basis_1
basis_2

tourr:::proj_dist(basis_1, basis_2)
tourr:::proj_dist(basis_0, basis_1)
tourr:::proj_dist(basis_0, basis_2)

```




#### 2D projection with `x1, x2, x7: x10` using `holes()` index

```{r eval =FALSE}
set.seed(123456)
polish_holes_mult <- animate_dist(data_mult[,c(1,2,7:10)], tour_path = guided_tour(holes(), d = 2,
                                                search_f = search_geodesic_latest),
                  rescale = FALSE, polish = TRUE, nloop = 30, polish_alpha = 0.05)
```


```{r}
polish_holes_mult %>% filter(info == "polish") 

basis <- polish_holes_mult %>% filter(info == "polish") %>% pull(basis)

basis_0 <- matrix(c(0, 1, 0, 0, 0, 0, 
                    0, 0, 1, 0, 0, 0), nrow = 6, ncol = 2) # theoretical optimal
basis_1 <- basis %>% first() # last basis from interpolation
basis_2 <- basis %>% last() # last basis after polishing

basis_1
basis_2

tourr:::proj_dist(basis_1, basis_2)
tourr:::proj_dist(basis_0, basis_1)
tourr:::proj_dist(basis_0, basis_2)

```

ToDo: 

1. Programming issue with accessing `index()` 

Currently, the `index()` function is declared inside the `generator()` and I don't know how to programmatically make it available in `search_polish()` - which is a function NOT part of the `guided_tour()` process. Also, we probably don't want to specify `holes()` twice inside the `animate_dist()`. 

2. searching scheme

We could think about adding a more structured searching scheme with cooling rate or more use more advanced algorithm but playing around with parameters: `polish_alpha` and `nloop` would give a pretty good result. Thus don't think it is necessary.


## Version 3 with all the nearby bases outputted 

I allow version 3 to output all the nearby bases to assess the efficiency of the sampling. The following plot shows the sampling of each loop in a panel and x-axis represents the distance between the current basis and the sampled basis. y-axi represents the index_val and the scale is different for each panel. Start from panel 1, the dot with proj_dist = 0 is the last basis from search_geodesic_latest & interpolation and 100 samples are taken at each alpha level. The point with the largest index value becomes the current point in panel 2 and this process keeps going for `nloop = 30` times. 

The shape of all the points in one panel is either a cone-like or meteor-like shape and this is explanable. In the initial stage of polishing, the basis is far from the one with the highest index_val, taking random samples around it will gives some points with higher index_val and some with lower. This creates the cone-like shape in the first few panels. In the end of polishing, the current basis is almost at the peak of the mountain. Going in any direction is likely to cause a decline in the index_val and the further one goes, the lower the index_val would be. 

The messages from this plot are two-fold: 

1) At the initial stage of polishing, a larger alpha value is more efficient 
2) When it coems to the end, a smaller alpha value is more likely to find a higher index_val

Based on these two messages, I no longer use a vector of alpha value in the sampling of nearby basis. Rather a relatively large alpha value is used to initialise the polishing procedure and a cooling parameter to adjust. 

The current `search_polish()` also implement the percentage change improvement. If the percentage change is less than 0.001, the cooling parameter will work to reduce the alpha value and continue the searching. It will end if the number of iteration > `nloop` or `polish_alpha < 0.001`.
 
```{r eval = FALSE}
set.seed(123456)
polish_holes_old_mult <- tourr::animate_dist(data_mult[,c(1,2,7:10)], tour_path = guided_tour(holes(), d = 2,
                                                                                              search_f = search_geodesic_latest),
                                             rescale = FALSE, polish = TRUE,
                                             nloop = 30, polish_alpha = 0.05)

polish_holes_old_mult_record <- polish_holes_old_mult$record
polish_holes_old_mult_sim <- polish_holes_old_mult$sim
```
 

```{r}
polish <- polish_holes_old_mult_record %>% filter(info == "polish")

sim <- polish_holes_old_mult_sim %>%
  mutate(basis_id = case_when(loop == 0 ~ 1, 
                              between(loop, 1, 16) ~ loop, 
                              loop > 16 ~ 16), 
         proj_dist = map2_dbl(basis, basis_id, ~tourr::proj_dist(polish$basis[[.y]], .x)))

sim %>%
  ggplot(aes(x = proj_dist, y = index_val, col = as.factor(alpha))) +
  geom_point(alpha = 0.5) +
  facet_wrap(vars(loop), scales = "free_y")

```

After these modification, search_polish is working well.

```{r eval = FALSE}
# search_polish modified
set.seed(123456)
polish_modified_mult <- tourr::animate_dist(data_mult[,c(1,2,7:10)],
                                            tour_path = guided_tour(holes(), d = 2,
                                                                    search_f = search_geodesic_latest),
                                            rescale = FALSE, polish = TRUE,
                                            nloop = 30, polish_alpha = 0.05)

polish_mult_modified_record <- polish_modified_mult$record
polish_mult_modified_sim <- polish_modified_mult$sim
```


```{r}
polish_mult_modified_record %>% filter(info == "polish")
```



