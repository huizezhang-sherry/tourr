---
title: "Choice of alpha and cooling parameter"
author: "Huize Zhang"
date: "10/02/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE)
library(tidyverse)
library(foreach)

load(here::here("sherry", "data", "better_alpha.rda"))
load(here::here("sherry", "data", "better_random_alpha.rda"))
load(here::here("sherry", "data", "geodesic_alpha.rda"))
load(here::here("sherry", "data", "geodesic_alpha2.rda"))
source(here::here("sherry", "compute_pca.R"))
```

Key points: 

`search_better()` & `search_better_random()`

- A larger cooling parameter leads to longer interpolation path but this doesn't necessarily translate into higher ending index_val

- A larger alpha parameter results in a more fluctuated interpolation path, which makes the algorithm less efficient.

- The difference between the two algorithm is not shown for combination of large cooling & alpha. 

- `search_better_random` doesn't result in better ending index_val than `search_better`, this could because eps is default to be too small.

- The default value of alpha and cooling could be set to better values. Suggest 0.2 - 0.3 for alpha and 0.8 - 0.85 for cooling

`search_geodesic`: 

- The search_geodesic doesn't seem to have high fluctuation in the interpolation path. 

- The default value of `delta` parameter could be set to better value: 0.5 would be good.


## Preliminary

The choose of alpha parameter requires causion.
 
 - An alpha value that is too small i.e. 1e-4, 1e-3 would not make the search
 
 - A small alpha value results in a close neighbourhood in the searching
with a cooling parameter, the searching space will become smaller and smaller.
Thus, the algorithm may not be able to find the global maximum

- A large alpha value allows for a larger searching space, however,
it is likely that there exists a basis on the interpolating path that has higher index_val this makes the searching inefficient

The choose of cooling parameter determins how fast alpha decreases in the tour.

## Simulation experiment

A simulation with different grid values of alpha and cooling parameter: 

- `search_better()` & `search_better_random()`

  - alpha: 0.1, 0.2, 0.3, 0.4 ,0.5(default)
  - cooling: 0.8, 0.85, 0.9, 0.95, 0.99(default), 0.995

- `search_geodesic()`

  - delta: 0.001, 0.01 (default), 0.1, 0.5

## Result

### Cooling and alpha parameter

**1. A starting parameter of `alpha = 0.5` is not efficient for `search_better()` & `search_better_random()`**
  
  - The default `alpha = 0.5` and `cooling = 0.99` 
  - Different cooling values for the same alpha value 
  - Different alpha values for the same cooling value

Potential solution: 

- set the alpha to 0.2 or 0.3 as default
- Stop the interpolating process if the index_val is keep decreasing for five interpolating basis. 

```{r default-paras}
trial <- better_alpha %>% filter(alpha == 0.5, cooling == 0.99)

temp <- trial %>% filter(info %in% c("new_basis","interpolation", "start"))
  
start <- temp %>% filter(info == "start") %>% mutate(id =1)

interp <- temp %>% 
  filter(info == "interpolation") %>% 
  mutate(id = row_number() + 1)

new_id <- interp %>% 
  group_by(tries) %>% 
  filter(row_number() == max(row_number())) %>% 
  pull(id)

new <- temp %>% filter(info == "new_basis") %>% mutate(id = new_id)

dt <- bind_rows(start, interp, new) %>% arrange(id)

interrupt_search_better_plot <- dt %>% 
  ggplot(aes(x = id, y = index_val, col = info)) + 
  geom_point() + 
  geom_line() + 
  ggtitle("search_better- default alpha = 0.5, cooling = 0.99")

ggsave(interrupt_search_better_plot, file = here::here("sherry/fig/interrupt_search_better_plot.png"))
```

The blue points are the target bases found in the search and the red path is the interpolation path. The searching are finding the target bases with higher index_val but there are points with even higher index_val on the interpolating path (see the hill shape). 

#### **cooling parameter**

Facet by alpha allows for seeing the effect of different cooling value under the same alpha. A larger alpha value makes the searching / interpolating path longer but it doesnt not translate into larger index_val. Also, the larger the alpha, the more fluctuate the searching path. The plot for  using `search_better_random()` shows the same information. 

```{r hill-climbing - cooling}
better_interp <- better_alpha %>% 
  filter(info == "interpolation") %>%
  group_by(alpha, cooling) %>%
  mutate(id = row_number()) %>% 
  ungroup() %>% 
  mutate(alpha = as.factor(alpha), 
         cooling = as.factor(cooling))

random_interp <- better_random_alpha %>%
  filter(info == "interpolation") %>%
  group_by(alpha, cooling) %>%
  mutate(id = row_number()) %>% 
  ungroup() %>% 
  mutate(alpha = as.factor(alpha), 
         cooling = as.factor(cooling))

better_interp %>%
  ggplot(aes(x = id, y = index_val, col = cooling)) +
  geom_line() +
  facet_wrap(vars(alpha)) + 
  ggtitle("search_better - different cooling values for the same alpha")
```

```{r eval = FALSE}
random_interp %>%
  ggplot(aes(x = id, y = index_val, col = cooling)) +
  geom_line() +
  facet_wrap(vars(alpha)) + 
  ggtitle("search_better_random - different cooling values for the same alpha")

```

#### **alpha parameter**

Plot the index_val along the interpolation path for different combination of alpha and cooling parameter. For all cooling parameters, the alpha = 0.5 path shows the heavy fluctuation in the interpolating path. It seems that an alpha value of 0.2 or 0.3 are more likely to attain a higher index_val. The plot for  using `search_better_random()` shows the same information. 

```{r better-hill-climbing}
better_interp %>%
  ggplot(aes(x = id, y = index_val, col = alpha)) +
  geom_line() +
  facet_wrap(vars(cooling)) + 
  ggtitle("search_better - different alpha values for the same cooling")
```


```{r better-random-hill-climbing, eval = FALSE}
random_interp %>%
  ggplot(aes(x = id, y = index_val, col = alpha)) +
  geom_line() +
  facet_wrap(vars(cooling)) + 
  ggtitle("search_better_random - different alpha values for the same cooling")
```


#### **ending index_val**

```{r better-index-val}
max_index_val <- better_alpha %>%
  filter(info == "new_basis") %>%
  group_by(alpha, cooling) %>%
  filter(index_val == max(index_val)) %>%
  ungroup() %>%
  mutate(alpha = as.factor(alpha),
         cooling = as.factor(cooling))

best_better <- max_index_val %>% filter(index_val == max(index_val))

max_index_val %>%
  ggplot(aes(x = alpha, y = cooling)) +
  geom_raster(aes(fill = index_val)) +
  geom_tile(data = best_better, size = 2, fill = NA, col = "red") +
  geom_text(aes(label = round(index_val, 4)), col = "white")
```

The tile plot shows the end index_val returned for different combination of the grid value. It suggested that a lower alpha value of 0.2 or 0.3 and a lower cooling parameter from 0.8 to 0.9 are likely to result in higher ending index_val. `search_better_random()` shows the same. 

```{r better-random-index-val}
random_max_index_val <- better_random_alpha %>%
  filter(info == "new_basis") %>%
  group_by(alpha, cooling) %>%
  filter(index_val == max(index_val)) %>%
  ungroup() %>%
  mutate(alpha = as.factor(alpha),
         cooling = as.factor(cooling))

best_random <- random_max_index_val %>% filter(index_val == max(index_val))

random_max_index_val %>%
  ggplot(aes(x = alpha, y = cooling)) +
  geom_raster(aes(fill = index_val)) +
  geom_tile(data = best_random, size = 2, fill = NA, col = "red") +
  geom_text(aes(label = round(index_val, 4)), col = "white")
```

### **2. Comparison between `search_better()` and `search_better_random()`**

- For a small alpha value, 0.1, the trigger of random step in `search_better_random` doesn't result in a larger ending index_val. 

- For combination of large cooling and alpha value, `search_better_random` is doing the same as `search_better`. This is because when the searching neighbourhood becomes large, the searching algorithm is likely to find a much better index_val that result in a large difference in `new_index-cur_index`. 

- We could also play around with different eps value to see if things would change if eps is larger.

```{r}
bind_rows(random_max_index_val,max_index_val) %>% 
  ggplot(aes(x = cooling , y = index_val, col = method)) + 
  geom_point() + 
  facet_wrap(vars(alpha))
```

```{r eval = FALSE}
bind_rows(random_max_index_val,max_index_val) %>% 
  ggplot(aes(x = alpha , y = index_val, col = method)) + 
  geom_point() + 
  facet_wrap(vars(cooling))
```



### **3. A starting value of `delta = 0.01` is also too small for search_geodesic()**

- simulate for a wider range of delta value `delta <- c(0.01, 0.02, 0.05, 0.07, 0.09,  seq(0.1, 0.9, 0.1))`

- `search_geodesic()` doesn't seem to have the hill-and-valley pattern in the searching path. 

- Different delta attains pretty similar ending `index_val`, depending on precision. (some paths are exactly the same, the plot below only show the distinct path).  

- The different of using different deltas affects the effectiveness of the directional search. As delta becomes larger, the "radius" of the searching becomes larger and the directional search is no longer a infinitesimal search (see the pca plot).  An ideal delta between 0.01 to 0.1 is recommended.

```{r compare-delta-index}
geodesic_clean <- geodesic_alpha2 %>%
  filter(info == "interpolation") %>%
  mutate(delta = as.factor(delta))

best <- geodesic_clean %>%
  group_by(delta) %>%
  mutate(id = row_number()) %>%
  filter(index_val == max(index_val))

nondup <- best %>%
  ungroup() %>%
  mutate(dup = duplicated(round(index_val, 4))) %>%
  filter(dup == FALSE)

geodesic_interp <- geodesic_clean %>%
   filter(delta %in% nondup$delta) %>% 
  group_by(delta) %>%
  mutate(id = row_number())

geodesic_interp %>% 
  ggplot(aes(x = id, y = index_val, col = delta)) +
  geom_path() +
  ggrepel::geom_text_repel(data = nondup, 
                           aes(label = round(index_val, 4)))
```

```{r compare-delta-pca}
pca2 <- geodesic_alpha2 %>% 
  pca_geodesic() %>%
  filter(info %in% c("start", "interpolation"))

pca2 %>%
  ggplot(aes(x= PC1, y = PC2, col = as.factor(delta))) +
  geom_point() +
  geom_point(data = filter(pca2, info == "start"), col = "red") +
  theme(aspect.ratio = 1) +
  facet_wrap(vars(delta))

```

```{r direction-search-index}
geodesic_alpha2 %>% 
  group_by(delta) %>% 
  mutate(id = row_number()) %>% 
  ggplot(aes(x = id, y = index_val, col = info)) + 
  geom_point() + 
  facet_wrap(vars(delta))
```

```{r direction-search-pca}
x2_object <- geodesic_alpha2 %>% 
  group_by(delta) %>% 
  pca_geodesic() 

x2_releveled <- x2_object %>% filter(info != "interpolation")

x2_object %>%
  ggplot(aes(x= PC1, y = PC2, col = info)) +
  geom_point() +
  geom_point(data = x2_releveled) +
  theme(aspect.ratio = 1) + 
  facet_wrap(vars(delta))
```
