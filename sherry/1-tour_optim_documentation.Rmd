---
title: "tour_optim_documentation"
author: "Huize Zhang"
date: "2/3/2020"
output: "html_document"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      cache = TRUE)
library(tidyverse)
library(magick)
library(patchwork)
```

# Tourr: overview

The computation of a tour involves two major stages: the generating and interpolating stage. Given a current projection basis and its corresponding index value, the generator aims to try to find a better basis with higher index value through optimisation and the better basis found is called the target basis. The interpolator interpolates the current and target basis geodesically. Currently there are three optimisers in the tourr package: `search_better()`, `search_better_random()` and `search_geodesic()`. 

- `search_better()` randomly generates a nearby basis and compute it index value. If the index value is larger than the current index value the new basis will be accepted and used as the current basis for the next iteration. This generate-then-accept process repeats for a pre-determined number of iterations. 

- `search_better_random()` modifies on top of `search_better()` to include a random component when the difference between the new index value and the current index value is less than a prescribed epsilon ($\varepsilon$). This stochastic component allows the optimisation to jump out of the local maximum.

- `search_geodesic()` uses a two-step procedure to find the basis with better index value. Five candidates bases are first generated randomly and the basis with the largest index value is chosen as the promising direction. This step is called the direction search. The line search step then optimises the basis (angle) along the most promising direction over a 90 degree window to find the target basis.  This two-step procedure completes one iteration in the algorithm and the algorithm ceases when the percentage change on the index value exceeds 0.001 or the number of iteration exceeds a pre-determined `max.tries`. Note that the current basis and index value should be updated in each iteration once a better target basis is found and this has yet to be implemented in the `search_geodesic()` function. 


# Global Object
To understand the searching path of the basis in the optimisation, a global object that records all the bases, index value and auxiliary information would be useful. The `animate_dist()` function has been modified to result a tibble object contains all the information mentioned above, on top of its animated visualisation display. 


# Demo
Here I present a demonstration of how to use the modified version of tourr package and principle component analysis to understand the optimisation searching path. Simulated data is generated using 4 random variables (`x1, x8, x9, x10`) and a bi-modal distribution (`x2`). The histogram of the five variables are presented below. 

```{r}
load(here::here("sherry", "data", "origin_dt.rda"))

origin_dt %>%
  ggplot(aes(x = values)) +
  geom_histogram(binwidth = 0.15) +
  geom_density(aes(y=0.15 * ..count..)) +
  facet_wrap(vars(names), ncol = 3)
```


## `search_geodesic()`

Using the `search_geodesic()` optimiser, the first five rows of the global object generated from the tour is shown below.

```{r}
load(here::here("sherry", "data", "x2_geodesic.rda"))
head(x2_geodesic)
```

Visualisation tools could help to visually inspect the bases from the tour. Using principle component analysis, we obtain the 2D projection of the 5D basis. The next three visualisations plot the first two principle components and allow us to draw some insights on the `search_geodesic` routine. 

<!-- - Colored by the stage in which the basis is generated, direction search bases are further away from the interpolating bases than the line search bases. This shows that the direction search provides a broad exploration of the vector space while line search bases are more clustered in a smaller space (plot 1).  -->

<!-- - Coloring the interpolating bases by start, target and interpolation on top of the direction and line search bases allows us to observe how the bases updated during the optimisation (plot 2). -->



```{r}
load(here::here("sherry", "data", "x2_object.rda"))

x2_object <- x2_object %>% 
  mutate(info2 = ifelse(info %in% c("best_line_search",
                                     "best_direction_search"), 
                        "best", "normal"),
         info3 = ifelse(info2 == "normal", as.character(info),
                        str_sub(info, start = 6L, end = -1L))) %>% 
  mutate(info3 = fct_relevel(info3, c("start", "direction_search", "line_search", "interpolation")), 
         info2 = as.factor(info2))

# colour by parts of optimisation (static)
x2_releveled <- x2_object %>%
  filter(info != "interpolation") 

x2_object %>% 
  ggplot(aes(x= PC1, y = PC2, col = info)) +
  geom_point() +
  geom_point(data = x2_releveled) +
  theme(aspect.ratio = 1)


# x2_object %>% 
#   ggplot(aes(x= PC1, y = PC2, col = info)) +
#   geom_point() +
#   theme(aspect.ratio = 1) 
```


```{r eval = FALSE}
# colour the interpolation from all the bases
x2_interpolate <- x2_object %>% 
  filter(info == "interpolation") %>% 
  mutate(id2 = lag(id),
         info4 = ifelse(is.na(id2), "start", 
                        ifelse(id2 - id == -1, "interpolation", "target")))

# # interpolation path
ggplot(data =x2_interpolate,
       aes(x= PC1, y = PC2)) +
  geom_point(aes(col = info4)) +
  geom_path(linetype = "dashed")


```

```{r geo-animate}
# colour by parts of optimisation (animation)
x2_animate <- x2_object %>%
  mutate(loop = ifelse(info == "start", 1, loop)) %>% 
  group_by(tries, loop, info3) %>%
  mutate(animate_id = group_indices())

geo_animate <- x2_animate %>%
  ggplot(aes(x = PC1, y = PC2, col = info)) +
  geom_point() +
  theme(aspect.ratio = 1, 
        legend.position = "none") +
  gganimate::transition_time(animate_id) +
  gganimate::shadow_mark()

p1 <- gganimate::animate(geo_animate, fps = 2)

```

```{r}
p1
```


```{r index-val-animate}
index_val_animate <- x2_animate %>% 
  ggplot(aes(x= animate_id, y= index_val, col = info)) + 
  geom_jitter(width = 0.0005) + 
  theme(aspect.ratio = 1) +
  gganimate::transition_time(animate_id) + 
  gganimate::shadow_mark()


p2 <- gganimate::animate(index_val_animate, fps = 2)
```

```{r combine}

a_mgif <- image_read(p1)
b_mgif <- image_read(p2)

new_gif <- image_append(c(a_mgif[1], b_mgif[1]))
for(i in 2:100){
  combined <- image_append(c(a_mgif[i], b_mgif[i]))
  new_gif <- c(new_gif, combined)
}

new_gif

```

```{r}

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

x2_path <- x2_animate %>% 
  ungroup() %>% 
  ggplot(aes(x= animate_id, y= index_val, col = info)) + 
  geom_point()
  #facet_zoom(x = (tries == 7 & info %in% c("direction_search",
  #                                               "best_direction_search")))
   #ylim = c(0.7866, 0.7875)
direction <- x2_animate %>% 
  filter(tries > 5, info != "line_search") %>% 
  ggplot(aes(x= animate_id, y= index_val, col = info)) + 
  geom_point() + 
  xlim(1, max(x2_animate$animate_id)) + 
  scale_color_manual(values = c(gg_color_hue(6)[2:3], gg_color_hue(6)[5:6])) + 
  theme(legend.position =  "none")
  
direction/ x2_path + 
  plot_layout(heights = c(1, 2), guides = "collect")

```

```{r index-val-id-animation}
x2_animate %>% 
  ggplot(aes(x = id, y = index_val, col = info))  + 
  geom_point() + 
  gganimate::transition_time(id) + 
  gganimate::shadow_mark()

 
x2_path_id <- x2_animate %>% 
  ggplot(aes(x = id, y = index_val, col = info))  + 
  geom_point()

direction_id <- x2_animate %>% 
  filter(tries > 5, info != "line_search") %>% 
  ggplot(aes(x= id, y= index_val, col = info)) + 
  geom_point() + 
  xlim(1, max(x2_animate$id)) + 
  scale_color_manual(values = c(gg_color_hue(6)[2:3], gg_color_hue(6)[5:6])) + 
  theme(legend.position =  "none")
  
direction_id/ x2_path_id + 
  plot_layout(heights = c(1, 2), guides = "collect")

 
#gridExtra::grid.arrange(p1, p2, index_val_line, nrow = 2)
```



## `search_better()`

```{r better-path}
load(here::here("sherry", "data", "x2_object_better.rda"))

# colour by parts of optimisation (static)
x2_better_releveled <- x2_object_better %>%
  filter(info != "interpolation") 

x2_object_better %>%
  ggplot(aes(x= PC1, y = PC2, col = info)) +
  geom_point() +
  geom_point(data = x2_better_releveled) +
  theme(aspect.ratio = 1)

```


```{r better-animation}
# colour by parts of optimisation (animation)
x2_better_animate <- x2_object_better %>%
  mutate(info = fct_relevel(info, c("start", "random_search",
                                    "new_basis", "interpolation"))) %>%
  group_by(tries, info) %>%
  mutate(animate_id = group_indices())

x2_better_animate %>%
  ggplot(aes(x = PC1, y = PC2, col = info)) +
  geom_point() +
  theme(aspect.ratio = 1) +
  gganimate::transition_time(animate_id) +
  gganimate::shadow_mark()


```


## `search_better_random()`

```{r better-random-path}
load(here::here("sherry", "data", "x2_object_better_random.rda"))

# colour by parts of optimisation (static)
x2_better_random_releveled <- x2_object_better_random %>%
  filter(info != "interpolation") 

x2_object_better_random %>%
  ggplot(aes(x= PC1, y = PC2, col = info)) +
  geom_point() +
  geom_point(data = x2_better_random_releveled) +
  theme(aspect.ratio = 1)
```


```{r better-random-animation}
# colour by parts of optimisation (animation)
x2_better_random_animate <- x2_object_better_random %>%
  mutate(info = fct_relevel(info, c("start", "random_search",
                                    "new_basis", "interpolation"))) %>%
  group_by(tries, info) %>%
  mutate(animate_id = group_indices())

x2_better_random_animate %>%
  ggplot(aes(x = PC1, y = PC2, col = info)) +
  geom_point() +
  theme(aspect.ratio = 1) +
  gganimate::transition_time(animate_id) +
  gganimate::shadow_mark()
```

```{r eval = FALSE}
x2_sim <- rbind(x2_geodesic, x2_object_better, x2_better_random) %>% 
  filter(info == c("start", "best_line_search", "new_basis")) %>% 
  group_by(method) %>% 
  mutate(id = row_number())

x2_sim %>% 
  ggplot(aes(x = id, y = index_val,col = method)) + 
  geom_line()
```


