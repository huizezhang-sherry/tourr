---
title: "tour_optim_documentation"
author: "Huize Zhang"
date: "2/3/2020"
output: ["pdf_document", "html_document"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)
library(tidyverse)
```

# Tourr: overview

In general, a tour procedure invovles two major stages: generating and interpolating stage. Given a current projection basis and its corresponding index value, the generator will try to find a better basis with higher index value through optimisation. The better basis found is called the target basis and the interpolator will interpolates the current and target basis geodesically. Currently there are three optimisers in the tourr package: `search_better()`, `search_better_random()` and `search_geodesic()`. 

- `search_better()` randomly generates a nearby basis and compute it index value. If the new index value is larger than the current index value the new basis will be accepted and used as the current basis for the next iteration. This process will iterate until convergence. 

- `search_better_random()` modifies on top of `search_better()` to include a random component when the difference between the new index value and the current index value is less than a prescribed epsilon. This stochastic compoennt allows the optimisation to jump out of the local maximum and search for other possibilities

- `search_geodesic()` uses a two-step procedure to find the basis with better index value. Five candidates bases are first generated randomly and the basis with the larget index value is choosen as the promising direction for the target basis. This step is called the direction search. The algorithm then optimises the basis (angle) along the most promising direction over a 90 degree window to find the target basis. This step is called the line search.  This two-step procedure completes one iteration in the algorithm and the algorithm ceases when the percentage change on the index value exceeds 0.001 or the number of iteration exceeds a pre-determined `max.tries`. Note that the current basis and index value should be updated in each iteration once a better target basis is found and this has yet to be implemented in the serach_geodesic function. 

[add the graph]


# Global Object

A global object that records all the bases, index value and auxiliary information would be useful to analysis the optimisation path of the tour and this has now been implemented in the tourr package. Along with the display the animated tour visualisation, the `animate_dist()` function would also results a tibble object that contains all the information mentioned above. 


# Demo

Simulated data is generated using 4 random variables (`x1, x8, x9, x10`) and a bi-modal distribution generated from two normal distribution with mean at -1 and 1 (`x2`) and variance of 1. The histogram of the five variables are presented below. 

```{r}
load("origin_dt.rda")

origin_dt %>%
  ggplot(aes(x = values)) +
  geom_histogram(binwidth = 0.15) +
  geom_density(aes(y=0.15 * ..count..)) +
  facet_wrap(vars(names), ncol = 3)
```

Using `search_geodesic()`, the global object generated from the tour is presented below.

```{r}
load("x2_geodesic.rda")
head(x2_geodesic)
```

Visualisation tools could help to visually inspect the bases from the tour. Using principle component analysis, we obtain the 2D projection of the 5D basis. The next three visualisations plot the first two principle components and allow us to draw some insights on the `search_geodesic` routine. 

- Colored by the stage in which the basis is generated, direction search bases are further away from the interpolating bases than the line search bases.

- Color the interpolating bases on top of the direction search and line search bases allows us to see the location of the interpolating bases better

- Magnify the interpolating bases provides visual insight on the path of how the bases are updated.

```{r}
load("x2_object.rda")

# colour by parts of optimisation
x2_object_path <- x2_object %>% filter(!info %in% c(NA, "linear_search_best"))
ggplot(data = x2_object_path, aes(x= PC1, y = PC2)) +
  geom_point(aes(col = info)) +
  theme(aspect.ratio = 1)

# colour the interpolation from all the bases
x2_interpolate <- x2_object %>% 
  filter(info == "interpolation") %>% 
  mutate(id2 = lag(id),
         info2 = ifelse(is.na(id2), "start", 
                        ifelse(id2 - id == -1, "interpolation", "target")))

ggplot(data = x2_object,
       aes(x= PC1, y = PC2)) +
  geom_point(alpha = 0.7) +
  geom_point(data = x2_interpolate, aes(col = info2)) + 
  theme(aspect.ratio = 1)


# interpolation path
ggplot(data =x2_interpolate,
       aes(x= PC1, y = PC2)) +
  geom_point(aes(col = info2)) +
  geom_path(linetype = "dashed") + 
  theme(aspect.ratio = 1)


```

